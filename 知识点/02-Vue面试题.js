/**
 * 1.MVC和MVVM区别
 * 
 * MVC
 * MVC全名是Model View Controller, 是模型(model)-视图(view)-控制器(controller)的缩写,
 * 一种软件设计典范
 * 
 * 1.1 Model(模型):是应用程序中用于处理应用程序数据逻辑的部分. 通常模型对象负责在数据库中存取数据
 * 1.2 View(视图):是应用程序中处理数据显示的部分. 通常视图是依据模型数据创建的
 * 1.3 Controller(控制器):是应用程序中处理用户交互的部分. 通常控制器负责从视图读取数据,控制用户
 *     输入,并向模型发送数据
 * 如图:02-1-1
 * 
 * MVC的思想:一句话描述就是 Controller 负责将Model的数据用View显示出来,换句话说就是在Controller
 * 里面把 Model 的数据赋值给 View.
 * 
 * MVVM
 * 
 * MVVM 新增了 VM类
 * 
 * 1.1 ViewModel层:做了两件事达到了数据的双向绑定 一是将[模型]转化成[视图],即将后端传递的数据转化成
 * 所看到的页面. 实现的方式是: 数据绑定. 二是将[视图]转化成 [模型], 即将所看到的页面转化成后端的数据.
 * 实现的方式是: DOM事件监听.
 * 如图:02-1-2
 * 
 * 整体看来,MVVM比MVC精简很多,不仅简化了业务与界面的依赖,还解决了数据频繁更新的问题,不用再用选择器操作
 * DOM元素. 因为在MVVM中, View不知道Model的存在, Model 和 ViewModel 也观察不到 View,这种低耦合模式
 * 提高代码的可重用性.
 */

/**
 * 2.为什么data是一个函数
 * 
 * 组件中的 data 写成一个函数,数据以函数返回值形式定义,这样每复用一次组件,就会返回一份新的data,类似于给
 * 每个组件实例创建一个私有的数据空间,让各个组件实例维护各自的数据. 而单纯的写成对象形式,就使得所有组件实例
 * 共用了一份data,就会造成一个变了然后全部组件会变的结果.
 */

/**
 * 3.Vue组件通讯有哪几种方式
 * 
 * 3.1 props和$emit父组件向子组件传递数据是通过prop传递的,子组件传递数据给父组件是通过$emit触发事件做到的
 * 3.2 $parent,$children获取当前组件的父组件和当前组件的子组件
 * 3.3 $attrs 和 $listeners A ->B ->C. Vue2.4开始提供了 $attrs 和 $listeners 来解决这个问题
 * 3.4 父组件中通过 provide 来提供变量,然后在子组件中通过 inject 来注入变量.(官方不推荐在实际业务中使用,但是写组件库时很常用).
 * 3.5 $refs获取组件实例
 * 3.6 eventBus兄弟组件数据传递 这种情况下可以使用事件总线的方式
 * 3.7 vuex 状态管理
 */

/**
 * 4.Vue的声明周期方法有哪些, 一般在哪一步发请求
 * 
 * 4.1 beforeCreate在实例初始化之后,数据观测(data observer) 和 event/watcher 事件配置之前被调用.
 *     在当前阶段 data, methods, computed以及watch上的数据和方法都不能被访问
 * 4.2 created实例已经创建完成之后被调用.在这一步,实例已完成以下的配置: 数据观测(data observer),属性和
 *     方法的运算, watch/event 事件回调. 这里没有 $el, 如果非要想与Dom进行交互,可以通过 vm.$nextTick 来访问Dom
 * 4.3 beforeMount在挂载开始之前被调用: 相关的render函数首次被调用.
 * 4.4 mounted在挂载完成后发生,在当前阶段,真实的Dom挂载完毕,数据完成双向绑定,可以访问到Dom节点
 * 4.5 beforeUpdate数据更新时调用,发生在虚拟DOM重新渲染和打补丁(patch)之前. 可以在这个钩子中进一步地更改状态,
 *     这不会触发附加的重渲染过程
 * 4.6 updated发生在更新完成之后,当前阶段组件Dom已完成更新.要注意的是避免在此期间更改数据,因为这可能会导致无限循环
 *     的更新,该钩子在服务器渲染期间不被调用.
 * 4.7 beforeDestroy实例销毁之前调用.在这一步,实例仍然完全可用.我们可以在这时进行善后收尾工作,比如清除计时器.
 * 4.8 destroyed Vue实例销毁后调用. 调用后, Vue实例指示的所有东西都会解除绑定,所有的时间监听器会被移除,所有的子实例也会被销毁.
 *     该钩子在服务器渲染期间不被调用.
 * 4.9 activated keep-alive专属,组件被激活时调用
 * 4.10 deactivated keep-alive专属, 组件被销毁时调用
 * 
 * 异步请求在哪一步发起?
 * 可以在钩子函数 created, beforeMount, mounted 中进行异步请求,因为在这三个钩子函数中,data已经创建,可以将服务端返回的数据
 * 进行赋值.
 * 如果异步请求不需要依赖Dom推荐在created钩子函数中调用异步请求,因为在created钩子函数中调用异步请求有以下优点:
 * 能更快获取到服务器数据,减少页面Loading时间;
 * ssr不支持beforeMount,mounted钩子函数,所以放在created中有助于一致性;
 */

/**
 * 5 v-if 和 v-show 的区别
 * 5.1 v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点.
 * 5.2 v-show会被编译成指令,条件不满足时控制样式将对应节点隐藏(display:none)
 * 
 * 使用场景
 * v-if适用于在运行时很少改变条件,不需要频繁切换条件的场景
 * v-show适用于需要非常频繁切换条件的场景
 * 
 * 扩展补充: display:none, visibility:hidden 和 opacity:0之间的区别?
 * 三者共同点都是隐藏.不同点:
 * 5.3 是否占据空间
 * display:none,隐藏之后不占位置; visibility:hidden, opacity:0,隐藏后任然占据位置.
 * 5.4 子元素是否继承
 * display:none -- 不会被子元素继承,父元素都不存在了,子元素也不会显示出.
 * visibility:hidden -- 会被子元素继承,通过设置子元素visibility:visible来显示子元素.
 * opacity:0 -- 会被子元素继承,但是不能设置子元素opacity:0来重新显示.
 * 5.5 时间绑定
 * display:none的元素都已经不再页面存在了,因此无法触发它绑定的事件
 * visibility:hidden不会触发它上面绑定的事件
 * opacity:0元素上面绑定的事件是可以触发的.
 * 5.6 过渡动画
 * transition对于display是无效的
 * transition对于visibility是无效的
 * transition对于opacity是有效
 */

/**
 * 6 说说vue内置指令
 * 如图02-6-1
 */

/**
 * 7 怎样理解Vue的单向数据流
 * 数据总是从父组件传到子组件,子组件没有权利修改父组件传过来的数据,只能请求父组件对原始数据进行修改.
 * 这样会防止从子组件意外改变父级组件的状态,从而导致你的应用的数据流向难以理解.
 * 注意:
 * 子组件直接用v-model绑定父组件传过来的prop这样是不规范的写法,开发环境会报警告
 * 
 * 如果实在要改变父组件的prop值,可以再data里面定义一个变量并用 prop的值初始化它之后用 $emit 通知父组件去修改
 */

/**
 * 8 computed 和 watch 的区别和运用的场景
 * computed是计算属性,依赖其他属性计算值,并且computed的值有缓存,只有当计算值变化才会返回内容,它可以设置getter和setter.
 * 
 * watch监听到值的变化就会执行回调,在回调中可以进行一些逻辑操作.
 * 
 * 计算属性一般用在模板渲染中,某个值是依赖了其他的响应式对象甚至是计算属性计算而来; 而侦听属性适用于观测某个值的变化去完成一段
 * 复杂的业务逻辑.
 */

/**
 * 9 v-if 与 V-for 为什么不建议一起使用
 * v-for和v-if不要在同一个标签中使用,因为解析时先解析v-for再解析v-if,如果遇到需要同时使用时可以考虑写成计算属性的方式.
 */

/**
 * 中等 <<<<<<<<<<<<<============================>>>>>>>>>>>>>
 */

/**
 * 10 Vue2.0响应式数据的原理
 * 整体思路是数据劫持+观察者模式
 * 
 * 对象内部通过defineReactive方法,使用Object.defineProperty将属性进行劫持(只会劫持已经存在的属性),数组则是通过重写数组方法
 * 来实现. 当页面使用对应属性时,每个属性都拥有自己的dep属性,存放他所依赖的watcher(依赖收集),当属性变化后会通过自己对象的watcher去
 * 更新(派发更新).
 */