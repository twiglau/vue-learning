/**
 * 1.讲下MVVM?
 */
/**
 * MVVM 是Model-View-ViewModel缩写,也就是把MVC中的Controller演变成
 * ViewModel. Model层代表数据模型,View代表UI组件.
 * 
 * ViewModel是View和Model层的桥梁,数据会绑定到viewModel层并自动将数据
 * 渲染到页面中,视图变化的时候会通知viewModel层更新数据.
 */

/**
 * 2.简单说下 Vue2.x 响应式数据原理?
 */
/**
 * Vue在初始化数据时,会使用Object.defineProperty重新定义data中的所有属性,当
 * 页面使用对应属性时,首先会进行依赖收集(收集当前组件的watcher)
 * 
 * 如果属性发生变化会通知相关依赖进行更新操作(发布订阅).
 */

/**
 * 3.Vu3.x响应式数据原理?
 */
/**
 * Vue3.x 改用 Proxy 替代 Object.defineProperty,因为Proxy可以直接
 * 监听对象和数组的变化,并且有多大13种拦截方法.
 * 
 * 并且作为新标准将受到浏览器厂商重点持续的性能优化.
 */

/**
 * 3.1 Proxy只会代理对象的第一层,那么Vue3又是怎样处理这个问题的?
 */
/**
 * 判断当前Reflect.get的返回值是否为Object,如果是则再通过reactive方法
 * 做代理,这样就实现了深度观测.
 */

/**
 * 3.2 检测数组的时候可能触发多次get/set,那么如何防止触发多次?
 */
/**
 * 可以判断key是否为当前被代理对象target自身属性,也可以判断旧值与新值
 * 是否相等,只有满足以上两个条件之一时,才有可能执行trigger.
 */

/**
 * 4.vue2.x中如何检测数组变化?
 */
/**
 * 使用了函数劫持的方式,重写了数组的方法,Vue将data中的数组进行了原型链重写,
 * 指向了自己定义的数组原型方法.
 * 
 * 这样当调用数组api时,可以通知依赖更新,如果数组中包含着引用类型,会对数组中
 * 的引用类型再次递归遍历进行监控,这样就实现了检测数组变化.
 */

/**
 * 5.nextTick实现原理是?
 */
/**
 * 在下次DOM更新循环结束之后执行延迟回调. 
 * nextTick主要使用了宏任务和微任务.根据执行环境分贝尝试采用
 * 
 * Promise
 * MutationObserver
 * setImmediate
 * 
 * 如果以上都不行则采用 setTimeout
 * 定义了一个异步方法,多次调用nextTick会将方法存入对列中,通过这个
 * 异步方法清空当前队列.
 */

/**
 * 6.Vue的生命周期
 */
/**
 * beforeCreate 是 new Vue() 之后触发的第一个钩子,在当前阶段 data,methods,
 * computed 以及 watch 上的数据和方法都不能被访问.
 * 
 * created 在实例创建完成后发生,当前阶段已经完成了数组观测,也就是可以使用数据,更改数据.
 * 在这里更改数据不会触发 updated 函数.可以做一些初始数据的获取,在当前阶段
 * 无法与Dom进行交互,如果非要想,可以通过vm.$nextTick 来访问 Dom.
 * 
 * beforeMount 发生在挂载之前,在这之前template模板已导入渲染函数render编译.
 * 而当前阶段虚拟Dom已经创建完成,即将开始渲染.在此时也可以对数据进行更改,不会触发
 * updated.
 * 
 * mounted 在挂载完成后发生,在当前阶段,真实的Dom挂载完毕, 数据完成双向绑定,可以访问到Dom节点,
 * 使用$refs属性对Dom进行操作.
 * 
 * beforeUpdate 发生在更新之前,也就是响应式数据发生更新,虚拟dom重新
 * 渲染之前被触发,你可以在当前阶段进行更改数据,不会造成重渲染.
 * 
 * updated 发生在更新完成之后,当前阶段组件Dom已完成更新.要注意的是
 * 避免在此期间更改数据,因为这可能导致无限循环更新.
 * 
 * beforeDestory 发生在实例销毁之前,在当前阶段实例完全可以被使用,我们
 * 可以在这时进行善后收尾工作,比如清除计时器.
 * 
 * destoryed 发生在实例销毁之后,这个时候只剩下了dom空壳,组件一杯拆解,
 * 数据绑定被卸除,监听被移出,子实例也统统被销毁.
 * 
 */

/**
 * 7.你的接口请求一般放在哪个声明周期中?
 */
/**
 * 接口请求一般放在mounted中,但需要注意的是服务器渲染时不支持mounted,
 * 需要放到created中.
 */

/**
 * 8.说下 Computed 和 Watch
 */
/**
 * 8.1 Computed本质是一个具备缓存的watcher,依赖的属性发生变化就会更新视图.
 *     适用于计算比较消耗性能的计算场景.
 *     当表达式过于复杂时,在模板中放入过多逻辑会让模板难以维护,可以将复杂的逻辑
 *     放入计算属性中处理.
 * 8.2 Watch没有缓存性,更多的是观察的作用,可以监听某些数据执行回调,当我们需要深度监听
 *     对象中的属性时,可以打开deep:true选项.
 *     这样便会对对象中的每一项进行监听.这样会带来性能问题,优化的话可以使用字符串
 *     形式监听,如果没有写到组件中,不要忘记使用unWatch手动注销.
 *     
 */

/**
 * 9.v-if 和 v-show 的区别
 */
/**
 * 当条件不成立时,V-if不会渲染 DOM 元素, v-show操作的是样式(display),切换
 * 当前DOM的显示和隐藏.
 */

/**
 * 10.组件中的data为什么是一个函数?
 */
/**
 * 一个组件被复用多次的话,也就会创建多个实例.本质上,这些实例用的都是同一个
 * 构造函数.如果 data 是对象的话, 对象属于引用类型,会影响到所有的实例.
 * 
 * 所以为了保证组件不同的实例之间data不冲突,data必须是一个函数.
 */

/**
 * 11 v-model 的原理?
 */
/**
 * v-model 本质就是一个语法糖,可以看成是 value + input 方法的语法糖. 
 * 可以通过model属性的prop 和 event 属性来进行自定义.
 * 
 * 原生的v-model, 会根据标签的不同生成不同的事件和属性.
 */

/**
 * 12 Vue事件绑定原理
 */
/**
 * 原生事件绑定是通过 addEventListener 绑定给真实元素的,组件事件绑定是
 * 通过vue 自定义的 $on 实现的.
 */

/**
 * 13 Vue模板编译原理?
 */
/**
 * 简单说,Vue的编译过程就是将 template 转化为 render 函数的过程,会经历
 * 以下阶段:
 * 
 * 生成AST树
 * 优化
 * codegen
 * 
 * 首先解析模板,生成 AST 语法树,使用大量的正则表达式对模板进行解析,
 * 遇到标签,文本的时候都会执行对应的钩子进行相关处理.
 * 
 * Vue的数据是响应式的,但其实模板中并不是所有的数据都是响应式的,有些数据
 * 首次渲染后就不会在变化,对应的DOM也不会变化.
 * 
 * 那么优化过程就是深度遍历 AST 树,按照相关条件对树节点进行标记,这些
 * 被标记的节点(静态节点)我们就可以跳过对它们的比对,对运行时的模板起到很大
 * 的优化作用.
 * 
 * 编译的最后一步是将优化后的 AST 树转换为可执行代码.
 */

/**
 * 14.Vue2.x 和 Vue3.x 渲染器的 diff 算法?
 */
/**
 * diff算法有以下过程
 * 
 * 同级比较,再比较子节点
 * 先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点,
 * 将旧的子节点移除)
 * 
 * 比较都有子节点的情况(核心 diff)
 * 递归比较子节点
 * 正常Diff两个数的时间复杂度是O(n^3),但实际情况下我们很少会进行跨层级的
 * 移动DOM,所以 Vue 将 Diff 进行了优化,从 O(n^3) -> O(n).
 * 
 * 只有当新旧 children 都为多个子节点时才需要用核心的Diff算法进行同层级比较.
 * 
 * Vue2的核心算法用了双端比较的算法,同时从新旧 children 的两端开始进行
 * 比较,借助key值找到可复用的节点,再进行相关操作.
 * 
 * 相比React 的 Diff 算法,同样情况下可以减少移动节点次数,减少不必要的性能
 * 损耗,更加的优雅.
 * 
 * Vue3.x借鉴了 ivi 算法和 inferno 算法
 * 在创建VNode 时就确定其类型,以及在 mount/patch 的过程中采用位运算来
 * 判断一个VNode的类型,在这个基础之上在配合核心的Diff算法.使得性能上较Vue2.x
 * 有了提升.(实际的实现可以结合Vue3.x源码看.)
 * 
 * 该算法中还运用了动态规划的思想求解最长递归子序列.
 */

/**
 * 15.虚拟Dom 以及 key 属性的作用?
 */
/**
 * 由于在浏览器中操作DOM是很昂贵的,频繁的操作DOM,会产生一定的性能问题. 这就是
 * 虚拟DOM的产生原因.
 * 
 * Vue2的 Virtual DOM 借鉴了开源库snabbdom 的实现.
 * 
 * Virtual DOM 本质就是用一个原生的JS对象去描述一个DOM节点. 是对真实
 * DOM的一层抽象. (也就是源码中的 VNode 类, 它定义在
 * src/core/vdom/vnode.js中.)
 * 
 * VirtualDOM 映射到真实DOM要经历 VNode 的 create,diff,patch等阶段.
 * 
 * [key的作用是尽可能的复用 DOM 元素. ]
 * 
 * 新旧children中的节点只有顺序是不同的时候,最佳的操作应该是通过
 * 移动元素的位置来达到更新的目的.
 * 
 * 需要在新旧children 的节点中保存映射关系,以便能够在旧children的节点
 * 中找到可复用的节点. key 也就是children 中节点的唯一标识.
 */

/**
 * 16.keep-alive?
 */
/**
 * keep-alive 可以实现组件缓存,当组件切换时不会对当前组件进行卸载.
 * 
 * 常用的两个属性 include/exclude,允许组件有条件的进行缓存.
 * 
 * 两个生命周期 activated/deactivated, 用来得知当前组件是否处于活跃状态.
 * 
 * keep-alive 的中还运用了 LRU(Least Recently Used)算法.
 */

/**
 * 17.Vue中组件生命周期调用顺序说一下?
 */
/**
 * 组件的调用顺序都是先父后子,渲染完成的顺序是先子后父.
 * 
 * 组件的销毁操作是先父后子,销毁完成的顺序是先子后父.
 * 
 * 加载渲染过程
 * 父beforeCreate -> 父created -> 父beforeMount
 * -> 子beforeCreate -> 子created -> 子beforeMount
 * -> 子mounted -> 父mounted
 * 
 * 子组件更新过程
 * 父beforeUpdate ->子beforeUpdate ->子updated ->父updated
 * 
 * 父组件更新过程
 * 父beforeUpdate -> 父updated
 * 
 * 销毁过程
 * 父beforeDestory -> 子beforeDestory -> 子destoryed -> 父destored
 */

/**
 * 18. Vue2.x 组件通信方式有哪些?
 */
/**
 * 父子组件通信
 * 
 * 父 -> 子 props, 子 -> 父 $on,$emit
 * 获取父子组件实例 $parent,$children
 * Ref获取实例的方式调用组件的属性或者方法
 * Provide, inject 官方不推荐使用,但是写组件库时很常用
 * 
 * 兄弟组件通信
 * Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue
 * Vuex
 * 
 * 跨级组件通信
 * Vuex
 * $attrs,$listeners
 * Provide,inject
 */

/**
 * 19.SSR 了解吗?
 */
/**
 * SSR也就是服务端渲染,也就是将Vue在客户端把标签渲染成 HTML 的工作放在
 * 服务端完成,然后再把html 直接返回客户端.
 * 
 * SSR有着更好的SEO, 并且首屏加载速度更快等优点,不过它也有一些缺点,比如我们的开发
 * 条件会受到限制.
 * 
 * 服务端渲染只支持 beforeCreate 和 created 两个钩子,当我们需要一些外部扩展
 * 库时需要特殊处理.
 * 
 */

/**
 * 20 做过哪些Vue的性能优化?
 */
/**
 * 20.1编码阶段
 * 
 * 20.1.1   尽量减少 data 中的数据, data 中的数据都会增加 getter 和 setter,会收集对应的watcher
 * 20.1.2   v-if 和 v-for 不能连用
 * 20.1.3   如果需要使用v-for给每项元素绑定事件时使用时间代理
 * 20.1.4   SPA页面采用 keep-alive 存在组件
 * 20.1.5   在更多的情况下, 使用v-if 替代 v-show
 * 20.1.6   key保证唯一
 * 20.1.7   使用路由懒加载,异步组件
 * 20.1.8   防抖,节流
 * 20.1.9   第三方模块按需 导入
 * 20.1.10  长列表滚动到可视区域动态加载
 * 20.1.11  图片懒加载
 * 20.1.12  SEO优化
 * 20.1.13  预渲染
 * 20.1.14  服务端渲染SSR
 * 20.1.15  打包优化
 * 20.1.16  压缩代码
 * 20.1.17  Tree Shaking/Scope Hoisting
 * 20.1.18  使用cdn加载第三方模块
 * 20.1.19  多线程打包happypack
 * 20.1.20  splitChunks 抽离公共文件
 * 20.1.21  sourceMap 优化
 * 20.1.22  用户体验
 * 20.1.23  骨架屏
 * 20.1.24  PWA
 * 20.1.25  还可以使用缓存(客户端缓存,服务端缓存)优化,服务端开启 gzip 压缩等.
 * 20.1.26  等等....
 */

